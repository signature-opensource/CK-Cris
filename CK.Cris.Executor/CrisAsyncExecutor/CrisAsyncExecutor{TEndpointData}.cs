using CK.Core;
using Microsoft.Extensions.DependencyInjection;
using System;
using System.Threading.Tasks;

namespace CK.Cris
{
    /// <summary>
    /// A caller viewed by a <see cref="CrisAsyncExecutor{TEndpointData}"/>.
    /// An instance of this class must be provided by the endpoint to the <see cref="CrisExecutor{T}.Execute(ICrisAsyncCaller{T}, T)"/>
    /// method.
    /// </summary>
    /// <typeparam name="TCallerInfo">The endpoint scope data type (see <see cref="EndpointDefinition{TScopeData}"/>).</typeparam>
    public interface ICrisAsyncCaller<TCallerInfo> where TCallerInfo : notnull
    {
        /// <summary>
        /// Must send the validation result back to the caller.
        /// If <see cref="CrisValidationResult.Success"/> is false, the job handling is terminated.
        /// </summary>
        /// <param name="monitor">The monitor to use.</param>
        /// <param name="job">The handled job.</param>
        /// <param name="validationResult">The validation result.</param>
        void ReturnCrisValidationResult( IActivityMonitor monitor, CrisAsyncJob<TCallerInfo> job, CrisValidationResult validationResult );

        /// <summary>
        /// Must send the event back to the caller (and may be to other parties).
        /// </summary>
        /// <param name="monitor">The monitor to use.</param>
        /// <param name="job">The currently handled job.</param>
        /// <param name="e">The event generated by the current request handling.</param>
        void ReturnEvent( IActivityMonitor monitor, CrisAsyncJob<TCallerInfo> job, IEvent e );

        /// <summary>
        /// Must send the final result back to the caller.
        /// </summary>
        /// <param name="monitor">The monitor to use.</param>
        /// <param name="job">The handled job.</param>
        /// <param name="result">The result.</param>
        void ReturnCommandResult( IActivityMonitor monitor, CrisAsyncJob<TCallerInfo> job, CrisAsyncExecutor.ICrisJobResult? result );
    }

    /// <summary>
    /// Base class to specialize with a specific <typeparamref name="TCallerInfo"/> type parameter
    /// to implement a new <see cref="ICrisAsyncExecutor"/>.
    /// </summary>
    /// <typeparam name="TCallerInfo">The endpoint scope data type (see <see cref="EndpointDefinition{TScopeData}"/>).</typeparam>
    public abstract partial class CrisAsyncExecutor<TCallerInfo> : CrisAsyncExecutor where TCallerInfo : notnull
    {
        readonly IPocoFactory<ICrisJobResult> _resultFactory;
        readonly IPocoFactory<ICrisResultError> _errorResultFactory;
        readonly IEndpointType<TCallerInfo> _endpointType;
        readonly RawCrisValidator _commandValidator;
        readonly RawCrisExecutor _commandExecutor;

        public CrisAsyncExecutor( IServiceProvider serviceProvider,
                                  RawCrisValidator commandValidator,
                                  RawCrisExecutor commandExecutor )
            : base( serviceProvider )
        {
            _resultFactory = serviceProvider.GetRequiredService<IPocoFactory<ICrisJobResult>>();
            _errorResultFactory = serviceProvider.GetRequiredService<IPocoFactory<ICrisResultError>>();
            _endpointType = endpointType;
            _commandValidator = commandValidator;
            _commandExecutor = commandExecutor;
        }

        /// <summary>
        /// Accepts a job that will be executed in the background.
        /// </summary>
        /// <param name="caller">The caller.</param>
        /// <param name="request">The job to execute.</param>
        public void BackgroundExecute( ICrisAsyncCaller<TCallerInfo> caller, CrisAsyncJob<TCallerInfo> job )
        {
            Throw.CheckNotNullArgument( caller );
            Throw.CheckNotNullArgument( job );
            Push( new ExecuteJob( caller, job ) );
        }

        sealed record class ExecuteJob( ICrisAsyncCaller<TCallerInfo> Caller, CrisAsyncJob<TCallerInfo> Job );

        private protected override ValueTask ExecuteTypedJobAsync( IActivityMonitor monitor, object job )
        {
            if( job is ExecuteJob c ) return HandleCommandAsync( monitor, c );
            return base.ExecuteTypedJobAsync( monitor, job );
        }

    }
}
